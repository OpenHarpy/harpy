package main

import (
	"context"
	"io"
	"log"
	"net"
	"runtime"

	pb "client-engine/grpc_ce_protocol"

	"client-engine/chunker"

	"client-engine/task"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc"
)

const (
	port = ":50051"
)

type TaskDefinition struct {
	Name            string
	CallableBinary  []byte
	ArgumentsBinary [][]byte
	KwargsBinary    map[string][]byte
}

func NewTaskDefinition(name string, callableBinary []byte, argumentsBinary [][]byte, kwargsBinary map[string][]byte) TaskDefinition {
	return TaskDefinition{
		Name:            name,
		CallableBinary:  callableBinary,
		ArgumentsBinary: argumentsBinary,
		KwargsBinary:    kwargsBinary,
	}
}

// Begin LiveMemory
type LiveMemory struct {
	// The Live Memory is a struct that holds all the live data of the server
	// It is used to store all the live data of the server
	Sessions           map[string]*task.Session
	TaskSetDefinitions map[string]*task.TaskSet
	TaskDefinitions    map[string]*TaskDefinition
}

func (lm *LiveMemory) CreateSession(options map[string]string) *task.Session {
	// Create a new session
	sess := task.NewSession(options)
	lm.Sessions[sess.SessionId] = sess
	return sess
}

func (lm *LiveMemory) CreateTaskSet(sess *task.Session) *task.TaskSet {
	// Create a new task set
	ts := sess.CreateTaskSet()
	lm.TaskSetDefinitions[ts.TaskSetId] = ts
	return ts
}

// End LiveMemory
type server struct {
	lm *LiveMemory
	pb.UnimplementedSessionServer
	pb.UnimplementedTaskSetServer
}

// CreateSession implements
func (s *server) CreateSession(ctx context.Context, in *pb.SessionRequest) (*pb.SessionHandler, error) {
	options := in.Options
	sess := s.lm.CreateSession(options)
	Info("Created session", "SESSION-SERVICE", logrus.Fields{"session_id": sess.SessionId})
	Info("Session options", "SESSION-SERVICE", logrus.Fields{"options": in.Options})
	return &pb.SessionHandler{SessionId: sess.SessionId}, nil
}
func (s *server) CloseSession(ctx context.Context, in *pb.SessionHandler) (*pb.SessionHandler, error) {
	// To close a session we will simply call close on the session and remove it from the live memory
	// Hopefully the garbage collector will take care of the rest
	sess, ok := s.lm.Sessions[in.SessionId]
	if !ok {
		Warn("session_not_found", "SESSION-SERVICE", logrus.Fields{"session_id": in.SessionId})
		return &pb.SessionHandler{SessionId: ""}, nil
	}
	sess.Close()
	delete(s.lm.Sessions, in.SessionId)
	Info("Closed session", "SESSION-SERVICE", logrus.Fields{"session_id": in.SessionId})
	runtime.GC() // Run the garbage collector
	return &pb.SessionHandler{SessionId: "", Success: true}, nil
}
func (s *server) CreateTaskSet(ctx context.Context, in *pb.SessionHandler) (*pb.TaskSetHandler, error) {
	sess, ok := s.lm.Sessions[in.SessionId]
	if !ok {
		Warn("session_not_found", "SESSION-SERVICE", logrus.Fields{"session_id": in.SessionId})
		return &pb.TaskSetHandler{TaskSetId: "", Success: false}, nil
	}
	ts := s.lm.CreateTaskSet(sess)
	Info("Created task set", "SESSION-SERVICE", logrus.Fields{"task_set_id": ts.TaskSetId})
	return &pb.TaskSetHandler{TaskSetId: ts.TaskSetId}, nil
}

type TaskDefinitionFull struct {
	Name            string
	CallableBinary  []byte
	ArgumentsBinary [][]byte
	KwargsBinary    map[string][]byte
}

func (s *server) DefineTask(stream pb.TaskSet_DefineTaskServer) error {
	callableBinary := []byte{}
	argumentsBinary := map[uint32][]byte{}
	kwargsBinary := map[string][]byte{}
	name := ""

	for {
		in, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		name = in.Name
		// The callable binary will be sent in chunks
		callableBinary = append(callableBinary, in.CallableBinary...)
		// The arguments binary will also be sent in chunks but there will be multiple arguments per chunk
		// It will be sent as a map of integer corresponding tp the index of the argument
		for key, value := range in.ArgumentsBinary {
			arg, ok := argumentsBinary[key]
			if !ok {
				argumentsBinary[key] = []byte{}
			}
			argumentsBinary[key] = append(arg, value...)
		}
		// Similarly the kwargs binary will be sent in chunks but there will be multiple kwargs per chunk
		// It will be sent as a map of string corresponding to the key of the kwarg
		for key, value := range in.KwargsBinary {
			kwarg, ok := kwargsBinary[key]
			if !ok {
				kwargsBinary[key] = []byte{}
			}
			kwargsBinary[key] = append(kwarg, value...)
		}
	}

	// once the stream is done we will create a task definition in the live memory
	argumentsSlice := make([][]byte, len(argumentsBinary))
	for key, value := range argumentsBinary {
		argumentsSlice[key] = value
	}

	taskDef := NewTaskDefinition(
		name,
		callableBinary,
		argumentsSlice,
		kwargsBinary,
	)
	taskDefId := uuid.New().String()
	s.lm.TaskDefinitions[taskDefId] = &taskDef
	Info("Defined task", "TASKSET-SERVICE", logrus.Fields{"task_id": taskDefId})
	return stream.SendAndClose(&pb.TaskHandler{TaskID: taskDefId})
}

func (s *server) AddMap(ctx context.Context, in *pb.MapAdder) (*pb.TaskAdderResult, error) {
	ts, ok := s.lm.TaskSetDefinitions[in.TaskSetHandler.TaskSetId]
	if !ok {
		Warn("task_set_not_found", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetHandler.TaskSetId})
		return &pb.TaskAdderResult{Success: false, ErrorMesssage: "Task Set not found"}, nil
	}

	// For each taskHandler under MappersDefinition we will create a task definition
	taskDefinitions := []task.MapperDefinition{}
	for _, taskHandler := range in.MappersDefinition {
		taskInMem, ok := s.lm.TaskDefinitions[taskHandler.TaskID]
		if !ok {
			Warn("task_definition_not_found", "TASKSET-SERVICE", logrus.Fields{"task_id": taskHandler.TaskID})
			return &pb.TaskAdderResult{Success: false, ErrorMesssage: "Task Definition not found"}, nil
		}
		taskDef := task.NewMapperDefinition(
			taskInMem.Name,
			taskInMem.CallableBinary,
			"remote",
			taskInMem.ArgumentsBinary,
			taskInMem.KwargsBinary,
		)
		taskDefinitions = append(taskDefinitions, taskDef)
		// We can now flush the task definition from the live memory
		delete(s.lm.TaskDefinitions, taskHandler.TaskID)
	}
	opt := map[string]string{}
	ts.Map(taskDefinitions, opt)
	Info("Added map to task set", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetHandler.TaskSetId})
	return &pb.TaskAdderResult{Success: true, ErrorMesssage: ""}, nil
}

func (s *server) AddReduce(ctx context.Context, in *pb.ReduceAdder) (*pb.TaskAdderResult, error) {
	ts, ok := s.lm.TaskSetDefinitions[in.TaskSetHandler.TaskSetId]
	if !ok {
		Warn("task_set_not_found", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetHandler.TaskSetId})
		return &pb.TaskAdderResult{Success: false, ErrorMesssage: "Task Set not found"}, nil
	}

	// Reducers only have one task definition
	taskHandler := in.ReducerDefinition
	taskInMem, ok := s.lm.TaskDefinitions[taskHandler.TaskID]
	if !ok {
		Warn("task_definition_not_found", "TASKSET-SERVICE", logrus.Fields{"task_id": taskHandler.TaskID})
		return &pb.TaskAdderResult{Success: false, ErrorMesssage: "Task Definition not found"}, nil
	}
	taskDef := task.NewReducerDefinition(
		taskInMem.Name,
		taskInMem.CallableBinary,
		"remote",
		taskInMem.ArgumentsBinary,
		taskInMem.KwargsBinary,
	)
	// We can now flush the task definition from the live memory
	delete(s.lm.TaskDefinitions, taskHandler.TaskID)
	opt := map[string]string{}
	ts.Reduce(taskDef, opt)
	Info("Added reduce to task set", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetHandler.TaskSetId})
	return &pb.TaskAdderResult{Success: true, ErrorMesssage: ""}, nil
}

func (s *server) AddTransform(ctx context.Context, in *pb.TransformAdder) (*pb.TaskAdderResult, error) {
	ts, ok := s.lm.TaskSetDefinitions[in.TaskSetHandler.TaskSetId]
	if !ok {
		Warn("task_set_not_found", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetHandler.TaskSetId})
		return &pb.TaskAdderResult{Success: false, ErrorMesssage: "Task Set not found"}, nil
	}

	// Transformers only have one task definition
	taskHandler := in.TransformerDefinition
	taskInMem, ok := s.lm.TaskDefinitions[taskHandler.TaskID]
	if !ok {
		Warn("task_definition_not_found", "TASKSET-SERVICE", logrus.Fields{"task_id": taskHandler.TaskID})
		return &pb.TaskAdderResult{Success: false, ErrorMesssage: "Task Definition not found"}, nil
	}
	taskDef := task.NewTransformerDefinition(
		taskInMem.Name,
		taskInMem.CallableBinary,
		"remote",
		taskInMem.ArgumentsBinary,
		taskInMem.KwargsBinary,
	)
	// We can now flush the task definition from the live memory
	delete(s.lm.TaskDefinitions, taskHandler.TaskID)
	opt := map[string]string{}
	ts.Transform(taskDef, opt)
	Info("Added transform to task set", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetHandler.TaskSetId})
	return &pb.TaskAdderResult{Success: true, ErrorMesssage: ""}, nil
}

func (s *server) Execute(ctx context.Context, in *pb.TaskSetHandler) (*pb.TaskSetStatus, error) {
	// Prior to executing we will force the garbage collector to run
	runtime.GC() // This is because we are removing task definitions from the live memory and we want to free up the memory
	ts := s.lm.TaskSetDefinitions[in.TaskSetId]
	Info("Executing task set", "TASKSET-SERVICE", logrus.Fields{"task_set_id": ts.TaskSetId})
	result, err := ts.Execute()
	if err != nil {
		Error("task_execution_error", "Error executing task set", err)
		return &pb.TaskSetStatus{TaskSetID: ts.TaskSetId, TaskSetStatus: "failed"}, nil
	}

	Info("Task set executed", "TASKSET-SERVICE", logrus.Fields{"task_set_id": result.Results})

	Info("Task set executed", "TASKSET-SERVICE", logrus.Fields{"task_set_id": ts.TaskSetId})
	return &pb.TaskSetStatus{TaskSetID: ts.TaskSetId, TaskSetStatus: result.OverallStatus}, nil
}

// GetTaskSetResults implements (Streaming)
//
//	rpc GetTaskSetResults (TaskSetHandler) returns (stream TaskSetResult) {}
func (s *server) GetTaskSetResults(in *pb.TaskSetHandler, stream pb.TaskSet_GetTaskSetResultsServer) error {
	ts := s.lm.TaskSetDefinitions[in.TaskSetId]
	Info("Getting task set result", "TASKSET-SERVICE", logrus.Fields{"task_set_id": ts.TaskSetId})

	tsResult := ts.GetTaskSetResult()
	if tsResult.OverallStatus == "pending" {
		// If the task set is still pending then we will just return
		return nil
	} else {
		// If the task set is completed then we will stream the results
		binary_index_map := map[int]*int{}  // map of result index to chunk index
		binary_stdout_map := map[int]*int{} // map of result index to chunk index
		binary_stderr_map := map[int]*int{} // map of result index to chunk index

		done_stream := map[int]bool{} // map of result index to done status
		all_streamed := false
		aggBytes := 0
		for !all_streamed {
			// While not all results ended
			for index, result := range tsResult.Results {
				_, ok := binary_index_map[index]
				if !ok {
					binary_index_map[index] = new(int)
					*binary_index_map[index] = 0
					binary_stdout_map[index] = new(int)
					*binary_stdout_map[index] = 0
					binary_stderr_map[index] = new(int)
					*binary_stderr_map[index] = 0
				}
				_, ok = done_stream[index]
				if !ok {
					done_stream[index] = false
				}

				current_done := done_stream[index]
				if !current_done {
					taskSetResultChunk := &pb.TaskSetResultChunk{
						TaskRunID:               result.TaskRunID,
						ObjectReturnBinaryChunk: chunker.ChunkBytes(result.ObjectReturnBinary, binary_index_map[index]),
						StdoutBinaryChunk:       chunker.ChunkBytes(result.StdoutBinary, binary_stdout_map[index]),
						StderrBinaryChunk:       chunker.ChunkBytes(result.StderrBinary, binary_stderr_map[index]),
						Success:                 result.Success,
					}

					aggBytes += len(taskSetResultChunk.ObjectReturnBinaryChunk)
					if len(taskSetResultChunk.ObjectReturnBinaryChunk) == 0 && len(taskSetResultChunk.StdoutBinaryChunk) == 0 && len(taskSetResultChunk.StderrBinaryChunk) == 0 {
						done_stream[index] = true
					}
					// Send the chunk
					err := stream.Send(taskSetResultChunk)
					if err != nil {
						return err
					}
				}
				// Check if all results are done
				exit_next := true
				for _, done := range done_stream {
					if !done {
						exit_next = false
						break
					}
				}
				all_streamed = exit_next
			}
		}
	}
	return nil
}

func (s *server) Dismantle(ctx context.Context, in *pb.TaskSetHandler) (*pb.TaskSetHandler, error) {
	// Dismantle the task set - For this we will simply remove the task set from the live memory
	//  Hopefully the garbage collector will take care of the rest
	delete(s.lm.TaskSetDefinitions, in.TaskSetId)
	Info("Dismantled task set", "TASKSET-SERVICE", logrus.Fields{"task_set_id": in.TaskSetId})
	return &pb.TaskSetHandler{TaskSetId: "", Success: true}, nil
}

func main() {
	SetupLogging()
	Info("Starting gRPC server", "SERVER")
	lm := &LiveMemory{
		Sessions:           make(map[string]*task.Session),
		TaskSetDefinitions: make(map[string]*task.TaskSet),
		TaskDefinitions:    make(map[string]*TaskDefinition),
	}

	lis, err := net.Listen("tcp", port)
	if err != nil {
		Error("failed_to_listen", "SERVER", err)
	}
	s := grpc.NewServer()
	pb.RegisterSessionServer(s, &server{lm: lm})
	pb.RegisterTaskSetServer(s, &server{lm: lm})

	Info("gRPC server started", "SERVER", logrus.Fields{"host": lis.Addr(), "port": port})
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
